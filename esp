local RunService = game:GetService('RunService')
local Players = game:GetService('Players')
local UserInputService = game:GetService('UserInputService')
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local esplib = getgenv().esplib
if not esplib then
    esplib = {
        enabled = true,
        box = {
            enabled = true,
            type = "normal", -- normal, corner
            padding = 1.15,
            fill = Color3.new(1,1,1),
            outline = Color3.new(0,0,0),
        },
        healthbar = {
            enabled = true,
            fill = Color3.new(0,1,0),
            outline = Color3.new(0,0,0),
        },
        name = {
            enabled = true,
            fill = Color3.new(1,1,1),
            size = 13,
        },
        distance = {
            enabled = true,
            fill = Color3.new(1,1,1),
            size = 13,
        },
        tracer = {
            enabled = true,
            fill = Color3.new(1,1,1),
            outline = Color3.new(0,0,0),
            from = "mouse", -- mouse, head, top, bottom, center
        },
        fade = {
            enabled = true,
            speed = 0.1,
        }
    }
    getgenv().esplib = esplib
end

local espinstances = {}
local espfunctions = {}

-- Função para obter bounding box
local function get_bounding_box(instance)
    local min, max = Vector2.new(math.huge, math.huge), Vector2.new(-math.huge, -math.huge)
    local onscreen = false

    if instance:IsA("Model") then
        for _, p in ipairs(instance:GetChildren()) do
            if p:IsA("BasePart") then
                local size = (p.Size / 2) * esplib.box.padding
                local cf = p.CFrame
                for _, offset in ipairs({
                    Vector3.new( size.X,  size.Y,  size.Z),
                    Vector3.new(-size.X,  size.Y,  size.Z),
                    Vector3.new( size.X, -size.Y,  size.Z),
                    Vector3.new(-size.X, -size.Y,  size.Z),
                    Vector3.new( size.X,  size.Y, -size.Z),
                    Vector3.new(-size.X,  size.Y, -size.Z),
                    Vector3.new( size.X, -size.Y, -size.Z),
                    Vector3.new(-size.X, -size.Y, -size.Z),
                }) do
                    local pos, visible = Camera:WorldToViewportPoint(cf:PointToWorldSpace(offset))
                    if visible then
                        local v2 = Vector2.new(pos.X, pos.Y)
                        min = min:Min(v2)
                        max = max:Max(v2)
                        onscreen = true
                    end
                end
            elseif p:IsA("Accessory") then
                local handle = p:FindFirstChild("Handle")
                if handle and handle:IsA("BasePart") then
                    local size = (handle.Size / 2) * esplib.box.padding
                    local cf = handle.CFrame
                    for _, offset in ipairs({
                        Vector3.new( size.X,  size.Y,  size.Z),
                        Vector3.new(-size.X,  size.Y,  size.Z),
                        Vector3.new( size.X, -size.Y,  size.Z),
                        Vector3.new(-size.X, -size.Y,  size.Z),
                        Vector3.new( size.X,  size.Y, -size.Z),
                        Vector3.new(-size.X,  size.Y, -size.Z),
                        Vector3.new( size.X, -size.Y, -size.Z),
                        Vector3.new(-size.X, -size.Y, -size.Z),
                    }) do
                        local pos, visible = Camera:WorldToViewportPoint(cf:PointToWorldSpace(offset))
                        if visible then
                            local v2 = Vector2.new(pos.X, pos.Y)
                            min = min:Min(v2)
                            max = max:Max(v2)
                            onscreen = true
                        end
                    end
                end
            end
        end
    elseif instance:IsA("BasePart") then
        local size = (instance.Size / 2)
        local cf = instance.CFrame
        for _, offset in ipairs({
            Vector3.new( size.X,  size.Y,  size.Z),
            Vector3.new(-size.X,  size.Y,  size.Z),
            Vector3.new( size.X, -size.Y,  size.Z),
            Vector3.new(-size.X, -size.Y,  size.Z),
            Vector3.new( size.X,  size.Y, -size.Z),
            Vector3.new(-size.X,  size.Y, -size.Z),
            Vector3.new( size.X, -size.Y, -size.Z),
            Vector3.new(-size.X, -size.Y, -size.Z),
        }) do
            local pos, visible = Camera:WorldToViewportPoint(cf:PointToWorldSpace(offset))
            if visible then
                local v2 = Vector2.new(pos.X, pos.Y)
                min = min:Min(v2)
                max = max:Max(v2)
                onscreen = true
            end
        end
    end

    return min, max, onscreen
end

-- Sistema de Fade
local fadeData = {}

local function updateFade(instance, humanoid)
    if not fadeData[instance] then
        fadeData[instance] = {
            alpha = 1,
            isDead = false,
            lastHealth = 100
        }
    end
    
    local data = fadeData[instance]
    local currentHealth = humanoid and humanoid.Health or 100
    
    -- Verifica se o jogador morreu ou reviveu
    if currentHealth <= 0 and data.lastHealth > 0 then
        data.isDead = true
    elseif currentHealth > 0 and data.lastHealth <= 0 then
        data.isDead = false
        data.alpha = 1
    end
    
    -- Aplica fade se estiver morto
    if data.isDead then
        data.alpha = math.max(0, data.alpha - esplib.fade.speed)
    else
        data.alpha = 1
    end
    
    data.lastHealth = currentHealth
    return data.alpha
end

-- Funções para adicionar elementos ESP
function espfunctions.add_box(instance)
    if not instance or espinstances[instance] and espinstances[instance].box then return end

    local box = {}

    local outline = Drawing.new("Square")
    outline.Thickness = 3
    outline.Filled = false
    outline.Transparency = 1
    outline.Visible = false

    local fill = Drawing.new("Square")
    fill.Thickness = 1
    fill.Filled = false
    fill.Transparency = 1
    fill.Visible = false

    box.outline = outline
    box.fill = fill

    box.corner_fill = {}
    box.corner_outline = {}
    for i = 1, 8 do
        local outline = Drawing.new("Line")
        outline.Thickness = 3
        outline.Transparency = 1
        outline.Visible = false

        local fill = Drawing.new("Line")
        fill.Thickness = 1
        fill.Transparency = 1
        fill.Visible = false
        table.insert(box.corner_fill, fill)
        table.insert(box.corner_outline, outline)
    end

    espinstances[instance] = espinstances[instance] or {}
    espinstances[instance].box = box
end

function espfunctions.add_healthbar(instance)
    if not instance or espinstances[instance] and espinstances[instance].healthbar then return end
    local outline = Drawing.new("Square")
    outline.Thickness = 1
    outline.Filled = true
    outline.Transparency = 1
    outline.Visible = false

    local fill = Drawing.new("Square")
    fill.Filled = true
    fill.Transparency = 1
    fill.Visible = false

    espinstances[instance] = espinstances[instance] or {}
    espinstances[instance].healthbar = {
        outline = outline,
        fill = fill,
    }
end

function espfunctions.add_name(instance)
    if not instance or espinstances[instance] and espinstances[instance].name then return end
    local text = Drawing.new("Text")
    text.Center = true
    text.Outline = true
    text.Font = 1
    text.Transparency = 1
    text.Visible = false

    espinstances[instance] = espinstances[instance] or {}
    espinstances[instance].name = text
end

function espfunctions.add_distance(instance)
    if not instance or espinstances[instance] and espinstances[instance].distance then return end
    local text = Drawing.new("Text")
    text.Center = true
    text.Outline = true
    text.Font = 1
    text.Transparency = 1
    text.Visible = false

    espinstances[instance] = espinstances[instance] or {}
    espinstances[instance].distance = text
end

function espfunctions.add_tracer(instance)
    if not instance or espinstances[instance] and espinstances[instance].tracer then return end
    local outline = Drawing.new("Line")
    outline.Thickness = 3
    outline.Transparency = 1
    outline.Visible = false

    local fill = Drawing.new("Line")
    fill.Thickness = 1
    fill.Transparency = 1
    fill.Visible = false

    espinstances[instance] = espinstances[instance] or {}
    espinstances[instance].tracer = {
        outline = outline,
        fill = fill,
    }
end

-- Função para adicionar ESP completo para um jogador
function espfunctions.add_player(player)
    if not player or player == LocalPlayer then return end
    
    local function setupCharacter(character)
        if not character then return end
        
        espfunctions.add_box(character)
        espfunctions.add_healthbar(character)
        espfunctions.add_name(character)
        espfunctions.add_distance(character)
        espfunctions.add_tracer(character)
    end
    
    if player.Character then
        setupCharacter(player.Character)
    end
    
    player.CharacterAdded:Connect(function(character)
        setupCharacter(character)
    end)
end

-- Função para remover ESP
function espfunctions.remove(instance)
    if not espinstances[instance] then return end
    
    local data = espinstances[instance]
    if data.box then
        data.box.outline:Remove()
        data.box.fill:Remove()
        for _, line in ipairs(data.box.corner_fill) do
            line:Remove()
        end
        for _, line in ipairs(data.box.corner_outline) do
            line:Remove()
        end
    end
    if data.healthbar then
        data.healthbar.outline:Remove()
        data.healthbar.fill:Remove()
    end
    if data.name then
        data.name:Remove()
    end
    if data.distance then
        data.distance:Remove()
    end
    if data.tracer then
        data.tracer.outline:Remove()
        data.tracer.fill:Remove()
    end
    
    espinstances[instance] = nil
    fadeData[instance] = nil
end

-- Loop principal
RunService.RenderStepped:Connect(function()
    if not esplib.enabled then
        for instance, data in pairs(espinstances) do
            if data.box then
                data.box.outline.Visible = false
                data.box.fill.Visible = false
                for _, line in ipairs(data.box.corner_fill) do line.Visible = false end
                for _, line in ipairs(data.box.corner_outline) do line.Visible = false end
            end
            if data.healthbar then
                data.healthbar.outline.Visible = false
                data.healthbar.fill.Visible = false
            end
            if data.name then data.name.Visible = false end
            if data.distance then data.distance.Visible = false end
            if data.tracer then
                data.tracer.outline.Visible = false
                data.tracer.fill.Visible = false
            end
        end
        return
    end

    for instance, data in pairs(espinstances) do
        if not instance or not instance.Parent then
            espfunctions.remove(instance)
            continue
        end

        if instance:IsA("Model") and not instance.PrimaryPart then
            continue
        end

        local min, max, onscreen = get_bounding_box(instance)
        local humanoid = instance:FindFirstChildOfClass("Humanoid")
        local alpha = updateFade(instance, humanoid)

        if alpha <= 0 then
            if data.box then
                data.box.outline.Visible = false
                data.box.fill.Visible = false
                for _, line in ipairs(data.box.corner_fill) do line.Visible = false end
                for _, line in ipairs(data.box.corner_outline) do line.Visible = false end
            end
            if data.healthbar then
                data.healthbar.outline.Visible = false
                data.healthbar.fill.Visible = false
            end
            if data.name then data.name.Visible = false end
            if data.distance then data.distance.Visible = false end
            if data.tracer then
                data.tracer.outline.Visible = false
                data.tracer.fill.Visible = false
            end
            continue
        end

        -- Box
        if data.box and esplib.box.enabled and onscreen then
            local box = data.box
            local x, y = min.X, min.Y
            local w, h = (max - min).X, (max - min).Y
            local len = math.min(w, h) * 0.25

            if esplib.box.type == "normal" then
                box.outline.Position = min
                box.outline.Size = max - min
                box.outline.Color = esplib.box.outline
                box.outline.Transparency = 1 - alpha
                box.outline.Visible = true

                box.fill.Position = min
                box.fill.Size = max - min
                box.fill.Color = esplib.box.fill
                box.fill.Transparency = 1 - alpha
                box.fill.Visible = true

                for _, line in ipairs(box.corner_fill) do line.Visible = false end
                for _, line in ipairs(box.corner_outline) do line.Visible = false end

            elseif esplib.box.type == "corner" then
                local fill_lines = box.corner_fill
                local outline_lines = box.corner_outline

                local corners = {
                    { Vector2.new(x, y), Vector2.new(x + len, y) },
                    { Vector2.new(x, y), Vector2.new(x, y + len) },
                    { Vector2.new(x + w - len, y), Vector2.new(x + w, y) },
                    { Vector2.new(x + w, y), Vector2.new(x + w, y + len) },
                    { Vector2.new(x, y + h), Vector2.new(x + len, y + h) },
                    { Vector2.new(x, y + h - len), Vector2.new(x, y + h) },
                    { Vector2.new(x + w - len, y + h), Vector2.new(x + w, y + h) },
                    { Vector2.new(x + w, y + h - len), Vector2.new(x + w, y + h) },
                }

                for i = 1, 8 do
                    local from, to = corners[i][1], corners[i][2]
                    local dir = (to - from).Unit
                    local oFrom = from - dir
                    local oTo = to + dir

                    local o = outline_lines[i]
                    o.From = oFrom
                    o.To = oTo
                    o.Color = esplib.box.outline
                    o.Transparency = 1 - alpha
                    o.Visible = true

                    local f = fill_lines[i]
                    f.From = from
                    f.To = to
                    f.Color = esplib.box.fill
                    f.Transparency = 1 - alpha
                    f.Visible = true
                end

                box.outline.Visible = false
                box.fill.Visible = false
            end
        elseif data.box then
            data.box.outline.Visible = false
            data.box.fill.Visible = false
            for _, line in ipairs(data.box.corner_fill) do line.Visible = false end
            for _, line in ipairs(data.box.corner_outline) do line.Visible = false end
        end

        -- Healthbar
        if data.healthbar and esplib.healthbar.enabled and onscreen then
            local outline, fill = data.healthbar.outline, data.healthbar.fill

            if humanoid then
                local height = max.Y - min.Y
                local padding = 1
                local x = min.X - 3 - 1 - padding
                local y = min.Y - padding
                local health = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
                local fillheight = height * health

                outline.Color = esplib.healthbar.outline
                outline.Position = Vector2.new(x, y)
                outline.Size = Vector2.new(1 + 2 * padding, height + 2 * padding)
                outline.Transparency = 1 - alpha
                outline.Visible = true

                fill.Color = esplib.healthbar.fill
                fill.Position = Vector2.new(x + padding, y + (height + padding) - fillheight)
                fill.Size = Vector2.new(1, fillheight)
                fill.Transparency = 1 - alpha
                fill.Visible = true
            else
                outline.Visible = false
                fill.Visible = false
            end
        elseif data.healthbar then
            data.healthbar.outline.Visible = false
            data.healthbar.fill.Visible = false
        end

        -- Name
        if data.name and esplib.name.enabled and onscreen then
            local text = data.name
            local center_x = (min.X + max.X) / 2
            local y = min.Y - 15

            local name_str = instance.Name
            if humanoid then
                local player = Players:GetPlayerFromCharacter(instance)
                if player then name_str = player.Name end
            end

            text.Text = name_str
            text.Size = esplib.name.size
            text.Color = esplib.name.fill
            text.Transparency = 1 - alpha
            text.Position = Vector2.new(center_x, y)
            text.Visible = true
        elseif data.name then
            data.name.Visible = false
        end

        -- Distance
        if data.distance and esplib.distance.enabled and onscreen then
            local text = data.distance
            local center_x = (min.X + max.X) / 2
            local y = max.Y + 5
            local dist
            
            if instance:IsA("Model") then
                if instance.PrimaryPart then
                    dist = (Camera.CFrame.Position - instance.PrimaryPart.Position).Magnitude
                else
                    local part = instance:FindFirstChildWhichIsA("BasePart")
                    dist = part and (Camera.CFrame.Position - part.Position).Magnitude or 999
                end
            else
                dist = (Camera.CFrame.Position - instance.Position).Magnitude
            end
            
            text.Text = tostring(math.floor(dist)) .. "m"
            text.Size = esplib.distance.size
            text.Color = esplib.distance.fill
            text.Transparency = 1 - alpha
            text.Position = Vector2.new(center_x, y)
            text.Visible = true
        elseif data.distance then
            data.distance.Visible = false
        end

        -- Tracer
        if data.tracer and esplib.tracer.enabled and onscreen then
            local outline, fill = data.tracer.outline, data.tracer.fill

            local from_pos = Vector2.new()
            local to_pos = (min + max) / 2

            if esplib.tracer.from == "mouse" then
                local mouse_location = UserInputService:GetMouseLocation()
                from_pos = Vector2.new(mouse_location.X, mouse_location.Y)
            elseif esplib.tracer.from == "head" then
                local head = instance:FindFirstChild("Head")
                if head then
                    local pos, visible = Camera:WorldToViewportPoint(head.Position)
                    from_pos = visible and Vector2.new(pos.X, pos.Y) or Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
                else
                    from_pos = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
                end
            elseif esplib.tracer.from == "bottom" then
                from_pos = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
            elseif esplib.tracer.from == "center" then
                from_pos = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
            else
                from_pos = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
            end

            outline.From = from_pos
            outline.To = to_pos
            outline.Color = esplib.tracer.outline
            outline.Transparency = 1 - alpha
            outline.Visible = true

            fill.From = from_pos
            fill.To = to_pos
            fill.Color = esplib.tracer.fill
            fill.Transparency = 1 - alpha
            fill.Visible = true
        elseif data.tracer then
            data.tracer.outline.Visible = false
            data.tracer.fill.Visible = false
        end
    end
end)

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        espfunctions.add_player(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function()
        task.wait(1)
        espfunctions.add_player(player)
    end)
end)

Players.PlayerRemoving:Connect(function(player)
    if player.Character then
        espfunctions.remove(player.Character)
    end
end)

for k, v in pairs(espfunctions) do
    esplib[k] = v
end

return esplib
